/*
 * LECTURE SLIDES PROCESSOR PLUGIN
 * Generated by Antigravity
 * Features: PDF Processing, Batch Mode, OCR Integration
 */

const { Plugin, PluginSettingTab, Setting, Notice, Modal, TFile, TFolder } = require("obsidian");

// ==================== DEFAULT SETTINGS ====================
const DEFAULT_SETTINGS = {
    outputFolderMode: "mitschriften",  // "same", "mitschriften", "custom"
    customOutputFolder: "",
    namingPattern: "{subject}VL{number}",
    autoOpenFirst: true,
    pdfPrinterCmd: "pdf-printer:convert-pdf-to-images",
    markerCmd: "marker-api:marker-convert-to-md",
    pollInterval: 2000,
    maxWaitPdfPrinter: 60000,
    maxWaitMarker: 120000,
    // Processing steps
    enablePdfToImages: true,
    enableOcr: true,
    enableStructureFix: true,
    enableSlideLinks: true,
    enableFrontmatter: true
};

// ==================== MAIN PLUGIN ====================
module.exports = class LectureSlidesPlugin extends Plugin {
    async onload() {
        await this.loadSettings();

        // Status bar
        this.statusBarItem = this.addStatusBarItem();
        this.statusBarItem.setText('');
        this.statusBarItem.addClass('lecture-slides-status');

        // Ribbon icon
        this.addRibbonIcon('presentation', 'Lecture Slides Processor', () => {
            new PDFPickerModal(this.app, this).open();
        });

        // Commands
        this.addCommand({
            id: 'open-lecture-processor',
            name: 'Process Lecture PDFs',
            callback: () => new PDFPickerModal(this.app, this).open()
        });

        this.addCommand({
            id: 'shift-slide-ids',
            name: 'Shift Slide IDs',
            callback: () => this.shiftSlideIds()
        });

        this.addCommand({
            id: 'expand-slide-content',
            name: 'Expand Slide Content',
            callback: () => this.expandSlideContent()
        });

        this.addCommand({
            id: 'repair-slide-links',
            name: 'Repair Missing Slide Links',
            callback: () => this.repairSlideLinks()
        });

        this.addCommand({
            id: 'cleanup-marker-output',
            name: 'Cleanup Marker Output (Remove Header/Footer Repeats)',
            callback: () => this.cleanupMarkerOutput()
        });

        this.addSettingTab(new LectureSlidesSettingTab(this.app, this));
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }

    setStatus(text) {
        if (this.statusBarItem) {
            this.statusBarItem.setText(text ? `üéì ${text}` : '');
            this.statusBarItem.addClass('processing');
        }
    }

    clearStatus() {
        if (this.statusBarItem) {
            this.statusBarItem.setText('');
            this.statusBarItem.removeClass('processing');
        }
    }

    // ==================== UTILITY COMMANDS ====================
    async shiftSlideIds() {
        const activeView = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
        if (!activeView) {
            new Notice("‚ùå No active markdown note");
            return;
        }

        const file = activeView.file;
        let content = await this.app.vault.read(file);

        // Simple prompt using Notice + clipboard workaround
        const offsetStr = await this.promptUser("Enter offset (e.g., +1 or -1):", "+1");
        if (!offsetStr) return;

        const offset = parseInt(offsetStr);
        if (isNaN(offset)) {
            new Notice("‚ùå Invalid offset");
            return;
        }

        let changeCount = 0;

        // Shift block ID references: #^slide-N
        content = content.replace(/#\^slide-(\d+)/g, (match, num) => {
            changeCount++;
            return `#^slide-${parseInt(num) + offset}`;
        });

        // Shift header references: #üìÑ Slide N
        content = content.replace(/#üìÑ Slide (\d+)/g, (match, num) => {
            changeCount++;
            return `#üìÑ Slide ${parseInt(num) + offset}`;
        });

        // Update display labels: |üìù Slide N]]
        content = content.replace(/\|üìù Slide (\d+)\]\]/g, (match, num) => {
            changeCount++;
            return `|üìù Slide ${parseInt(num) + offset}]]`;
        });

        await this.app.vault.modify(file, content);
        new Notice(`‚úÖ Shifted ${changeCount} references by ${offset > 0 ? '+' : ''}${offset}`);
    }

    async expandSlideContent() {
        const activeView = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
        if (!activeView) {
            new Notice("‚ùå No active markdown note");
            return;
        }

        const editor = activeView.editor;
        const cursor = editor.getCursor();
        const currentLine = cursor.line;

        // Search for slide link
        let foundLink = null;
        let linkLine = -1;
        const searchOffsets = [0, 1, -1, 2, -2, 3, -3];

        for (const offset of searchOffsets) {
            const i = currentLine + offset;
            if (i < 0 || i >= editor.lineCount()) continue;

            const line = editor.getLine(i);
            let match = line.match(/\[\[([^\]#]+\.md)#\^slide-(\d+)/);
            if (!match) match = line.match(/\[\[([^\]#]+\.md)#üìÑ Slide (\d+)/);

            if (match) {
                foundLink = { fullPath: match[1], slideNumber: parseInt(match[2]) };
                linkLine = i;
                break;
            }
        }

        if (!foundLink) {
            new Notice("‚ùå No slide link found near cursor");
            return;
        }

        // Get the MD file
        let targetFile = this.app.vault.getAbstractFileByPath(foundLink.fullPath);
        if (!targetFile) {
            targetFile = this.app.metadataCache.getFirstLinkpathDest(foundLink.fullPath, activeView.file.path);
        }

        if (!targetFile) {
            new Notice(`‚ùå File not found: ${foundLink.fullPath}`);
            return;
        }

        const mdContent = await this.app.vault.read(targetFile);
        const sections = mdContent.split(/\r?\n---\r?\n/);
        let slideContent = "";

        for (const section of sections) {
            if (section.includes(`## üìÑ Slide ${foundLink.slideNumber}`)) {
                slideContent = section.replace(/\n\^slide-\d+\s*$/m, '').trim();
                break;
            }
        }

        if (!slideContent) {
            new Notice(`‚ùå Slide ${foundLink.slideNumber} not found`);
            return;
        }

        const contentToInsert = `\n\n---\n**üìñ Slide ${foundLink.slideNumber} Notes:**\n\n${slideContent}\n\n---\n`;
        editor.replaceRange(contentToInsert, { line: linkLine + 1, ch: 0 });
        new Notice(`‚úÖ Slide ${foundLink.slideNumber} inserted!`);
    }

    async promptUser(message, defaultValue) {
        return new Promise((resolve) => {
            const modal = new PromptModal(this.app, message, defaultValue, resolve);
            modal.open();
        });
    }

    // ==================== REPAIR SLIDE LINKS ====================
    async repairSlideLinks() {
        const activeView = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
        if (!activeView) {
            new Notice("‚ùå No active markdown note");
            return;
        }

        const file = activeView.file;
        let content = await this.app.vault.read(file);

        // Try to find md_source from frontmatter
        const mdSourceMatch = content.match(/md_source:\s*\[\[([^\]]+)\]\]/);
        if (!mdSourceMatch) {
            new Notice("‚ùå No md_source found in frontmatter");
            return;
        }

        const markerMdPath = mdSourceMatch[1];
        const markerFile = this.app.vault.getAbstractFileByPath(markerMdPath);

        if (!markerFile) {
            new Notice(`‚ùå Marker file not found: ${markerMdPath}`);
            return;
        }

        // Verify Marker file has the correct structure
        const markerContent = await this.app.vault.read(markerFile);
        if (!markerContent.includes("## üìÑ Slide")) {
            new Notice("‚ùå Marker file doesn't have slide headers. Run structure fix first.");
            return;
        }

        // Find all image embeds that don't have slide links
        // Pattern: ![[NAME-N.webp]] NOT followed by > [[...Slide...]]
        const imagePattern = /!?\[\[([^\]]+)-(\d+)\.webp\]\]/g;
        let match;
        let addedLinks = 0;
        let newContent = content;

        // Get basename from first image to use for matching
        const firstImageMatch = content.match(/!?\[\[([^\]]+)-\d+\.webp\]\]/);
        if (!firstImageMatch) {
            new Notice("‚ùå No slide images found in note");
            return;
        }
        const imageBasename = firstImageMatch[1];

        // Check each line for images without links
        const lines = newContent.split('\n');
        const newLines = [];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            newLines.push(line);

            // Check if this line has an image embed
            const imgMatch = line.match(new RegExp(`!\\[\\[${imageBasename}-(\\d+)\\.webp\\]\\]`));
            if (imgMatch) {
                const imageIndex = parseInt(imgMatch[1]);
                const slideNum = imageIndex + 1; // Images are 0-indexed, slides are 1-indexed

                // Check if next line already has a slide link
                const nextLine = lines[i + 1] || '';
                const hasSlideLink = nextLine.includes(`#üìÑ Slide ${slideNum}`) ||
                    nextLine.includes(`#^slide-${slideNum}`);

                if (!hasSlideLink) {
                    // Add the slide link
                    const slideLink = `> [[${markerMdPath}#üìÑ Slide ${slideNum}|üìù Slide ${slideNum}]]`;
                    newLines.push(slideLink);
                    addedLinks++;
                }
            }
        }

        if (addedLinks === 0) {
            new Notice("‚úÖ All images already have slide links!");
            return;
        }

        newContent = newLines.join('\n');
        await this.app.vault.modify(file, newContent);
        new Notice(`‚úÖ Added ${addedLinks} missing slide links!`);
    }

    // ==================== CLEANUP MARKER OUTPUT ====================
    async cleanupMarkerOutput() {
        const activeView = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
        if (!activeView) {
            new Notice("‚ùå No active markdown note");
            return;
        }

        let file = activeView.file;
        let content = await this.app.vault.read(file);

        const mdSourceMatch = content.match(/md_source:\s*\[\[([^\]]+)\]\]/);
        if (mdSourceMatch) {
            const markerMdPath = mdSourceMatch[1];
            const markerFile = this.app.vault.getAbstractFileByPath(markerMdPath);
            if (markerFile) {
                file = markerFile;
                new Notice(`üßπ Cleaning source file: ${file.name}`);
                await this.cleanupMarkerContent(file);
                return;
            }
        }

        await this.cleanupMarkerContent(file);
    }

    async cleanupMarkerContent(file) {
        let content = await this.app.vault.read(file);
        const patterns = [
            /TECHNISCHE\s+UNIVERSIT√ÑT\s+DRESDEN/gi,
            /Institut\s+f√ºr\s+Werkstoffwissenschaft/gi,
            /Fakult√§t\s+Maschinenwesen\s+‚Äì\s+Institut\s+f√ºr\s+Werkstoffwissenschaft.*/gi,
            /Professur\s+f√ºr\s+Werkstofftechnik.*/gi,
            /Prof\.\s+Dr\.-Ing\.\s+Christoph\s+Leyens/gi,
            /Unterlagen\s+nur\s+f√ºr\s+den\s+pers√∂nlichen\s+Gebrauch/gi,
            /Folie\s+\d+\/\d+/gi,
            /INSTITUT\s+F√úR\s+WERKSTOFF/gi,
            /WERKSTOFF\s+BEZIRK[^\n]*/gi,
            /Kontakt:\s+werkstofftechnik@tu-dresden\.de/gi,
            /ifW/g,
            /^\d+\.\s+Werkstoffeigenschaften\s+und\s+‚Äìpr√ºfung.*$/gm,
            /^\d+\.\s+Werkstoffverhalten\s+bei\s+erh√∂hten\s+Temperaturen.*$/gm
        ];

        let cleanupCount = 0;
        let newContent = content;

        for (const pattern of patterns) {
            const matches = newContent.match(pattern);
            if (matches) {
                cleanupCount += matches.length;
                newContent = newContent.replace(pattern, '');
            }
        }

        newContent = newContent.replace(/\n{3,}/g, '\n\n');

        if (content !== newContent) {
            await this.app.vault.modify(file, newContent);
            if (cleanupCount > 0) new Notice(`‚úÖ Removed ${cleanupCount} boilerplate items directly`);
        } else {
            new Notice("‚úÖ No boilerplate found.");
        }
    }

    // ==================== CORE PROCESSING ====================
    async processPDF(pdfFile, options = {}) {
        const log = options.log || ((msg) => new Notice(msg, 3000));
        const settings = this.settings;

        log(`üìÑ Processing: ${pdfFile.name}`);

        // Extract metadata from path
        const pathParts = pdfFile.path.split("/");
        let subject = "";
        let semester = "";
        let lectureNumber = "";
        let subjectIndex = -1;
        let semesterIndex = -1;

        for (let i = 0; i < pathParts.length; i++) {
            if (pathParts[i].includes("Semester") && i + 1 < pathParts.length) {
                semester = pathParts[i];
                subject = pathParts[i + 1];
                semesterIndex = i;
                subjectIndex = i + 1;
            }
        }

        const vlMatch = pdfFile.basename.match(/VL(\d+)/i);
        if (vlMatch) lectureNumber = vlMatch[1];

        // Ensure Subject and Semester notes exist
        if (semester && subject && semesterIndex >= 0 && subjectIndex >= 0) {
            try {
                // 1. Check/Create Semester Note
                // Reconstruct path to semester folder: "20 Studies/3. Semester"
                const semesterFolderPath = pathParts.slice(0, semesterIndex + 1).join("/");
                const semesterNotePath = `${semesterFolderPath}/${semester}.md`;

                if (!this.app.vault.getAbstractFileByPath(semesterNotePath)) {
                    log(`‚ú® Creating Semester Note: ${semester}`);
                    await this.app.vault.create(semesterNotePath, `# ${semester}\n\n`);
                }

                // 2. Check/Create Subject Note
                // Reconstruct path to subject folder: "20 Studies/3. Semester/Werkstofftechnik"
                const subjectFolderPath = pathParts.slice(0, subjectIndex + 1).join("/");
                const subjectNotePath = `${subjectFolderPath}/${subject}.md`;

                if (!this.app.vault.getAbstractFileByPath(subjectNotePath)) {
                    log(`‚ú® Creating Subject Note: ${subject}`);
                    // Link to semester
                    await this.app.vault.create(subjectNotePath, `# ${subject}\n\nSemester: [[${semester}]]\n`);
                } else {
                    // Start: Optional - Verify Subject links to Semester? 
                    // For now, simpler is safer: just rely on existence.
                    // End Optional
                }

            } catch (err) {
                log(`‚ö†Ô∏è Error creating parent notes: ${err.message}`);
                console.error(err);
            }
        }

        // Determine output folder
        let outputFolder = pdfFile.parent.path;
        if (settings.outputFolderMode === "mitschriften") {
            // Replace /misc with /Mitschriften (sibling folder)
            // e.g., "20 Studies/3. Semester/Werkstofftechnik/misc" ‚Üí "20 Studies/3. Semester/Werkstofftechnik/Mitschriften"
            if (outputFolder.includes("/misc")) {
                outputFolder = outputFolder.replace(/\/misc(\/.*)?$/, "/Mitschriften");
            } else if (outputFolder.includes("\\misc")) {
                outputFolder = outputFolder.replace(/\\misc(\\.*)?$/, "/Mitschriften");
            }
        } else if (settings.outputFolderMode === "custom" && settings.customOutputFolder) {
            outputFolder = settings.customOutputFolder;
        }

        // Create output folder if needed
        if (!(await this.app.vault.adapter.exists(outputFolder))) {
            await this.app.vault.createFolder(outputFolder);
        }

        // Generate note name
        const noteName = settings.namingPattern
            .replace("{subject}", subject)
            .replace("{number}", lectureNumber)
            .replace("{basename}", pdfFile.basename);

        const notePath = `${outputFolder}/${noteName}.md`;

        // Check if note already exists
        if (await this.app.vault.adapter.exists(notePath)) {
            log(`‚ö†Ô∏è Note already exists: ${notePath}`);
            return { success: false, path: notePath, error: "Already exists" };
        }

        // Create initial note with PDF embed
        // Use wikilinks for initial content if possible? User template had just # Subject...
        // We will just keep standard header for now.
        const initialContent = `# ${subject} - Vorlesung ${lectureNumber}\n\n![[${pdfFile.path}]]\n`;
        await this.app.vault.create(notePath, initialContent);
        log(`üìù Created note: ${noteName}`);

        const noteFile = this.app.vault.getAbstractFileByPath(notePath);

        // Step 1: PDF to Images
        if (settings.enablePdfToImages) {
            log("üñ®Ô∏è Converting PDF to images...");

            // Open the note and select the PDF line
            const leaf = this.app.workspace.getLeaf(false);
            await leaf.openFile(noteFile);
            await new Promise(r => setTimeout(r, 500));

            const editor = this.app.workspace.activeLeaf?.view?.editor;
            if (editor) {
                for (let i = 0; i < editor.lineCount(); i++) {
                    const line = editor.getLine(i);
                    if (line.includes(`![[${pdfFile.path}`) || line.includes(`![[${pdfFile.name}`)) {
                        editor.setSelection({ line: i, ch: 0 }, { line: i, ch: line.length });
                        break;
                    }
                }
            }

            try {
                await this.app.commands.executeCommandById(settings.pdfPrinterCmd);
            } catch (e) {
                log(`‚ö†Ô∏è PDF Printer error: ${e.message}`);
            }

            // Wait for images
            const imagePattern = new RegExp(`!\\[\\[${pdfFile.basename}-\\d+\\.webp\\]\\]`);
            let waited = 0;
            while (waited < settings.maxWaitPdfPrinter) {
                await new Promise(r => setTimeout(r, settings.pollInterval));
                waited += settings.pollInterval;

                const content = await this.app.vault.read(noteFile);
                if (imagePattern.test(content)) {
                    log(`‚úÖ Images detected after ${waited / 1000}s`);
                    break;
                }
            }
        }

        // Step 2: OCR/Marker
        const pdfFolder = pdfFile.parent.path;
        const markerMdPath = `${pdfFolder}/${pdfFile.basename}/${pdfFile.basename}.md`;

        if (settings.enableOcr) {
            log("ü§ñ Running OCR/Marker...");

            try {
                const pdfLeaf = this.app.workspace.getLeaf(true);
                await pdfLeaf.openFile(pdfFile);
                await new Promise(r => setTimeout(r, 2000));

                await this.app.commands.executeCommandById(settings.markerCmd);

                // Wait for Marker output
                let waited = 0;
                while (waited < settings.maxWaitMarker) {
                    await new Promise(r => setTimeout(r, settings.pollInterval));
                    waited += settings.pollInterval;

                    const mdFile = this.app.vault.getAbstractFileByPath(markerMdPath);
                    if (mdFile) {
                        const content = await this.app.vault.read(mdFile);
                        if (content.length > 100) {
                            log(`‚úÖ Marker complete after ${waited / 1000}s`);
                            break;
                        }
                    }
                }

                pdfLeaf.detach();
            } catch (e) {
                log(`‚ö†Ô∏è Marker error: ${e.message}`);
            }
        }

        // Step 3: Fix structure
        if (settings.enableStructureFix) {
            log("üìù Fixing markdown structure...");

            const markerFile = this.app.vault.getAbstractFileByPath(markerMdPath);
            if (markerFile) {
                let mdContent = await this.app.vault.read(markerFile);

                if (!mdContent.includes("## üìÑ Slide") || !mdContent.includes("^slide-")) {
                    const pages = mdContent.split(/^---$/m);

                    let newMdContent = "";
                    for (let i = 0; i < pages.length; i++) {
                        let section = pages[i].trim();
                        if (!section) continue;

                        // Demote headers
                        section = section.replace(/^(#+ )/gm, "##$1");

                        if (i > 0) newMdContent += "\n\n---\n\n";
                        newMdContent += `## üìÑ Slide ${i + 1}\n\n${section}`;
                        newMdContent += `\n\n^slide-${i + 1}`;
                    }

                    await this.app.vault.modify(markerFile, newMdContent);
                    log(`‚úÖ Structure fixed for ${pages.length} slides`);
                }
                if (settings.enableStructureFix) {
                    await this.cleanupMarkerContent(markerFile);
                }
            }
        }

        // Step 4: Add slide links
        if (settings.enableSlideLinks) {
            log("üîó Adding slide links...");

            let content = await this.app.vault.read(noteFile);
            const imageRegex = new RegExp(`!\\[\\[${pdfFile.basename}-(\\d+)\\.webp\\]\\]`, 'g');
            const images = [...content.matchAll(imageRegex)];

            for (let i = 0; i < images.length; i++) {
                const slideNum = i + 1;
                const imageEmbed = `![[${pdfFile.basename}-${i}.webp]]`;
                const slideLink = `[[${markerMdPath}#üìÑ Slide ${slideNum}|üìù Slide ${slideNum}]]`;

                if (!content.includes(`[[${markerMdPath}#üìÑ Slide ${slideNum}`)) {
                    const linkedBlock = `![[${pdfFile.basename}-${i}.webp]]\n> ${slideLink}`;
                    content = content.replace(imageEmbed, linkedBlock);
                }
            }

            await this.app.vault.modify(noteFile, content);
            log(`‚úÖ Added ${images.length} slide links`);
        }

        // Step 5: Frontmatter
        if (settings.enableFrontmatter) {
            log("üìã Adding metadata...");

            let content = await this.app.vault.read(noteFile);
            const today = new Date().toISOString().split('T')[0];

            // Use wikilinks for Subject and Semester if they were found/created
            const subjectValue = subject ? `[[${subject}]]` : "";
            const semesterValue = semester ? `[[${semester}]]` : "";

            const metadata = {
                title: `${subject} - Vorlesung ${lectureNumber}`,
                date: today,
                subject: subjectValue,
                semester: semesterValue,
                lecture: lectureNumber,
                pdf: `[[${pdfFile.path}]]`,
                md_source: `[[${markerMdPath}]]`,
                tags: ["uni", "vorlesung", subject.replace(/[\[\]]/g, "").toLowerCase().replace(/\s+/g, "-")]
            };

            let frontmatter = "---\n";
            for (const [key, value] of Object.entries(metadata)) {
                if (!value) continue; // Skip empty fields

                if (Array.isArray(value)) {
                    frontmatter += `${key}:\n`;
                    value.forEach(v => frontmatter += `  - ${v}\n`);
                } else {
                    frontmatter += `${key}: ${value}\n`;
                }
            }
            frontmatter += "---\n\n";

            // Remove old frontmatter if exists
            if (content.startsWith("---")) {
                content = content.replace(/^---[\s\S]*?---\n*/, "");
            }

            content = frontmatter + content;
            await this.app.vault.modify(noteFile, content);
        }

        log(`üéâ Complete: ${noteName}`);
        return { success: true, path: notePath };
    }
};

// ==================== PDF PICKER MODAL ====================
class PDFPickerModal extends Modal {
    constructor(app, plugin) {
        super(app);
        this.plugin = plugin;
        this.selectedPDFs = new Set();
        this.isProcessing = false;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass('lecture-slides-modal');

        contentEl.createEl('h2', { text: 'üéì Lecture Slides Processor' });

        // Get all PDFs in vault
        const allFiles = this.app.vault.getFiles();
        const pdfFiles = allFiles.filter(f => f.extension === 'pdf');

        // Filter to likely lecture PDFs (in Studies folder, contains VL)
        const lecturePDFs = pdfFiles.filter(f =>
            f.path.includes('Studies') || f.path.includes('Semester') || /VL\d+/i.test(f.name)
        );

        // PDF List
        contentEl.createEl('h3', { text: `üìÅ Select PDFs (${lecturePDFs.length} found)` });

        const listContainer = contentEl.createDiv({ cls: 'pdf-list-container' });

        if (lecturePDFs.length === 0) {
            listContainer.createEl('p', { text: 'No lecture PDFs found. PDFs should be in a Studies or Semester folder.' });
        } else {
            for (const pdf of lecturePDFs) {
                const item = listContainer.createDiv({ cls: 'pdf-item' });

                const checkbox = item.createEl('input', { type: 'checkbox' });
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        this.selectedPDFs.add(pdf.path);
                        item.addClass('selected');
                    } else {
                        this.selectedPDFs.delete(pdf.path);
                        item.removeClass('selected');
                    }
                    this.updateButtonState();
                });

                item.createSpan({ text: pdf.name, cls: 'pdf-name' });
                item.createSpan({ text: pdf.parent.path, cls: 'pdf-path' });

                item.addEventListener('click', (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                        checkbox.dispatchEvent(new Event('change'));
                    }
                });
            }
        }

        // Options
        contentEl.createEl('h3', { text: '‚öôÔ∏è Options' });

        new Setting(contentEl)
            .setName('Output folder')
            .addDropdown(d => d
                .addOption('mitschriften', 'Mitschriften/ (replace misc/)')
                .addOption('same', 'Same as PDF')
                .addOption('custom', 'Custom folder')
                .setValue(this.plugin.settings.outputFolderMode)
                .onChange(async v => {
                    this.plugin.settings.outputFolderMode = v;
                    await this.plugin.saveSettings();
                })
            );

        // Progress container (hidden initially)
        this.progressContainer = contentEl.createDiv({ cls: 'progress-container' });
        this.progressContainer.style.display = 'none';

        this.progressText = this.progressContainer.createDiv({ cls: 'progress-status' });
        const barOuter = this.progressContainer.createDiv({ cls: 'progress-bar-outer' });
        this.progressBar = barOuter.createDiv({ cls: 'progress-bar-inner' });
        this.progressBar.style.width = '0%';
        this.progressLog = this.progressContainer.createDiv({ cls: 'progress-log' });

        // Buttons
        const buttonContainer = contentEl.createDiv({ cls: 'modal-button-container' });
        buttonContainer.style.marginTop = '16px';
        buttonContainer.style.display = 'flex';
        buttonContainer.style.justifyContent = 'flex-end';
        buttonContainer.style.gap = '8px';

        this.cancelBtn = buttonContainer.createEl('button', { text: 'Cancel' });
        this.cancelBtn.addEventListener('click', () => this.close());

        this.processBtn = buttonContainer.createEl('button', {
            text: 'üöÄ Process Selected',
            cls: 'mod-cta'
        });
        this.processBtn.disabled = true;
        this.processBtn.addEventListener('click', () => this.startProcessing());
    }

    updateButtonState() {
        const count = this.selectedPDFs.size;
        this.processBtn.textContent = count > 0 ? `üöÄ Process ${count} PDF${count > 1 ? 's' : ''}` : 'üöÄ Process Selected';
        this.processBtn.disabled = count === 0 || this.isProcessing;
    }

    async startProcessing() {
        if (this.selectedPDFs.size === 0) return;

        this.isProcessing = true;
        this.processBtn.disabled = true;
        this.cancelBtn.textContent = 'Close';
        this.progressContainer.style.display = 'block';

        const pdfs = [...this.selectedPDFs].map(path =>
            this.app.vault.getAbstractFileByPath(path)
        ).filter(f => f);

        let completed = 0;
        const results = [];

        for (const pdf of pdfs) {
            this.progressText.textContent = `Processing ${completed + 1}/${pdfs.length}: ${pdf.name}`;
            this.progressBar.style.width = `${(completed / pdfs.length) * 100}%`;

            const log = (msg) => {
                const line = this.progressLog.createDiv();
                if (msg.includes('‚úÖ')) line.addClass('log-success');
                else if (msg.includes('‚ùå') || msg.includes('‚ö†Ô∏è')) line.addClass('log-error');
                else line.addClass('log-info');
                line.textContent = msg;
                this.progressLog.scrollTop = this.progressLog.scrollHeight;
            };

            try {
                const result = await this.plugin.processPDF(pdf, { log });
                results.push(result);
            } catch (e) {
                log(`‚ùå Error: ${e.message}`);
                results.push({ success: false, error: e.message });
            }

            completed++;
            this.progressBar.style.width = `${(completed / pdfs.length) * 100}%`;
        }

        const successful = results.filter(r => r.success).length;
        this.progressText.textContent = `‚úÖ Complete! ${successful}/${pdfs.length} processed successfully.`;

        // Open first result if enabled
        if (this.plugin.settings.autoOpenFirst && results[0]?.success) {
            const firstNote = this.app.vault.getAbstractFileByPath(results[0].path);
            if (firstNote) {
                await this.app.workspace.openLinkText(results[0].path, "", false);
            }
        }

        this.isProcessing = false;
        new Notice(`üéâ Processed ${successful}/${pdfs.length} PDFs`);
    }

    onClose() {
        this.contentEl.empty();
    }
}

// ==================== PROMPT MODAL ====================
class PromptModal extends Modal {
    constructor(app, message, defaultValue, callback) {
        super(app);
        this.message = message;
        this.defaultValue = defaultValue;
        this.callback = callback;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.createEl('p', { text: this.message });

        const input = contentEl.createEl('input', { type: 'text', value: this.defaultValue });
        input.style.width = '100%';
        input.focus();

        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                this.callback(input.value);
                this.close();
            } else if (e.key === 'Escape') {
                this.callback(null);
                this.close();
            }
        });

        const btnContainer = contentEl.createDiv();
        btnContainer.style.marginTop = '12px';
        btnContainer.style.display = 'flex';
        btnContainer.style.justifyContent = 'flex-end';
        btnContainer.style.gap = '8px';

        const cancelBtn = btnContainer.createEl('button', { text: 'Cancel' });
        cancelBtn.addEventListener('click', () => {
            this.callback(null);
            this.close();
        });

        const okBtn = btnContainer.createEl('button', { text: 'OK', cls: 'mod-cta' });
        okBtn.addEventListener('click', () => {
            this.callback(input.value);
            this.close();
        });
    }

    onClose() {
        this.contentEl.empty();
    }
}

// ==================== SETTINGS TAB ====================
class LectureSlidesSettingTab extends PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display() {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.addClass('lecture-slides-settings');

        containerEl.createEl('h2', { text: 'üéì Lecture Slides Processor' });

        // Output Settings
        containerEl.createEl('h3', { text: 'üìÅ Output Settings' });

        new Setting(containerEl)
            .setName('Output folder mode')
            .setDesc('Where to create lecture notes')
            .addDropdown(d => d
                .addOption('mitschriften', 'Mitschriften/ (replace misc/)')
                .addOption('same', 'Same folder as PDF')
                .addOption('custom', 'Custom folder')
                .setValue(this.plugin.settings.outputFolderMode)
                .onChange(async v => {
                    this.plugin.settings.outputFolderMode = v;
                    await this.plugin.saveSettings();
                    this.display();
                })
            );

        if (this.plugin.settings.outputFolderMode === 'custom') {
            new Setting(containerEl)
                .setName('Custom output folder')
                .setDesc('Path relative to vault root')
                .addText(t => t
                    .setValue(this.plugin.settings.customOutputFolder)
                    .onChange(async v => {
                        this.plugin.settings.customOutputFolder = v;
                        await this.plugin.saveSettings();
                    })
                );
        }

        new Setting(containerEl)
            .setName('Note naming pattern')
            .setDesc('Available: {subject}, {number}, {basename}')
            .addText(t => t
                .setValue(this.plugin.settings.namingPattern)
                .onChange(async v => {
                    this.plugin.settings.namingPattern = v;
                    await this.plugin.saveSettings();
                })
            );

        new Setting(containerEl)
            .setName('Auto-open first note')
            .setDesc('Open the first processed note when batch completes')
            .addToggle(t => t
                .setValue(this.plugin.settings.autoOpenFirst)
                .onChange(async v => {
                    this.plugin.settings.autoOpenFirst = v;
                    await this.plugin.saveSettings();
                })
            );

        // Processing Steps
        containerEl.createEl('h3', { text: '‚öôÔ∏è Processing Steps' });

        new Setting(containerEl)
            .setName('Convert PDF to images')
            .setDesc('Use PDF Printer plugin')
            .addToggle(t => t
                .setValue(this.plugin.settings.enablePdfToImages)
                .onChange(async v => {
                    this.plugin.settings.enablePdfToImages = v;
                    await this.plugin.saveSettings();
                })
            );

        new Setting(containerEl)
            .setName('Run OCR/Marker')
            .setDesc('Extract text using Marker API')
            .addToggle(t => t
                .setValue(this.plugin.settings.enableOcr)
                .onChange(async v => {
                    this.plugin.settings.enableOcr = v;
                    await this.plugin.saveSettings();
                })
            );

        new Setting(containerEl)
            .setName('Fix markdown structure')
            .setDesc('Add slide headers and demote headings')
            .addToggle(t => t
                .setValue(this.plugin.settings.enableStructureFix)
                .onChange(async v => {
                    this.plugin.settings.enableStructureFix = v;
                    await this.plugin.saveSettings();
                })
            );

        new Setting(containerEl)
            .setName('Add slide links')
            .setDesc('Link images to corresponding slide text')
            .addToggle(t => t
                .setValue(this.plugin.settings.enableSlideLinks)
                .onChange(async v => {
                    this.plugin.settings.enableSlideLinks = v;
                    await this.plugin.saveSettings();
                })
            );

        new Setting(containerEl)
            .setName('Add frontmatter')
            .setDesc('Extract and add metadata')
            .addToggle(t => t
                .setValue(this.plugin.settings.enableFrontmatter)
                .onChange(async v => {
                    this.plugin.settings.enableFrontmatter = v;
                    await this.plugin.saveSettings();
                })
            );

        // Advanced
        containerEl.createEl('h3', { text: 'üîß Advanced' });

        new Setting(containerEl)
            .setName('PDF Printer command')
            .addText(t => t
                .setValue(this.plugin.settings.pdfPrinterCmd)
                .onChange(async v => {
                    this.plugin.settings.pdfPrinterCmd = v;
                    await this.plugin.saveSettings();
                })
            );

        new Setting(containerEl)
            .setName('Marker command')
            .addText(t => t
                .setValue(this.plugin.settings.markerCmd)
                .onChange(async v => {
                    this.plugin.settings.markerCmd = v;
                    await this.plugin.saveSettings();
                })
            );

        new Setting(containerEl)
            .setName('Max wait for PDF Printer (ms)')
            .addText(t => t
                .setValue(String(this.plugin.settings.maxWaitPdfPrinter))
                .onChange(async v => {
                    this.plugin.settings.maxWaitPdfPrinter = parseInt(v) || 60000;
                    await this.plugin.saveSettings();
                })
            );

        new Setting(containerEl)
            .setName('Max wait for Marker (ms)')
            .addText(t => t
                .setValue(String(this.plugin.settings.maxWaitMarker))
                .onChange(async v => {
                    this.plugin.settings.maxWaitMarker = parseInt(v) || 120000;
                    await this.plugin.saveSettings();
                })
            );
    }
}
